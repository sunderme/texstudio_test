# autogenerated by txs
#include:datatool-base
#include:etex
#include:ifthen
#include:substr
#include:xfor
#include:xkeyval
\DTLaddcolumn{db}{dbkey}#
\DTLaddentryforrow{db}{assign list}{condition}{dbkey}{value}#
\DTLappendtorow{dbkey}{value}#
\DTLassign{db}{row index}{assign list}#*
\DTLassignfirstmatch{db}{dbkey}{value}{assign list}#*
\xDTLassignfirstmatch{db}{dbkey}{value}{assign list}#*
\DTLcleardb{db}#
\DTLcolumncount{db}#
\DTLcomputebounds{db}{x key}{y key}{minX%cmd}{minY%cmd}{maxX%cmd}{maxY%cmd}#*
\DTLcurrencytype#*
\DTLcurrentindex
\DTLdeletedb{db}#
\DTLdisplaydb[omit list]{db}#
\DTLdisplaylongdb[keyvals]{db}#
#keyvals:\DTLdisplaylongdb
caption
label
shortcaption
contcaption
omit
foot
lastfoot
#endkeyvals
\DTLfetch{db}{dbkey}{value}{dkey2}
\DTLforeach[condition]{db}{assign list}{text}
\DTLforeach*[condition]{db}{assign list}{text}
\DTLforeachkeyinrow{cmd}{text}
\DTLgcleardb{db}
\DTLgdeletedb{db}#
\DTLgetcolumnindex{cmd}{db}{dbkey}
\DTLgetdatatype{cmd}{db}{dbkey}
\DTLgetkeydata{dbkey}{db}{col cs%cmd}{type cs%cmd}{header cs%cmd}
\DTLgetkeyforcolumn{cmd}{db}{column index}
\DTLgetlocation{row cs%cmd}{column cs%cmd}{db}{value}#*
\DTLgetrowforkey{arg}{arg2}{arg3}{arg4}#S
\DTLgetrowindex{row cs%cmd}{db}{col idx}{value}#*
\DTLgetvalueforkey{cmd}{dbkey}{db}{ref key}{ref value}#*
\DTLgetvalue{cmd}{db}{row}{column}#*
\DTLgnewdb{db}#s#%datatoolDB
\DTLifdbempty{db}{true case}{false case}#*
\DTLifdbexists{db}{true case}{false case}#*
\DTLiffirstrow{true case}{false case}#*
\DTLifhaskey{db}{dbkey}{true case}{false case}#*
\DTLiflastrow{true case}{false case}#*
\DTLifnull{cmd seq}{true case}{false case}#*
\DTLifnullorempty{cmd seq}{true case}{false case}#*
\DTLifoddrow{true case}{false case}#*
\DTLinttype#*
\DTLloaddb[options]{db}{filename}#s#%datatoolDB
\DTLloadsbtex{cmd}{filename}#*
\DTLloadrawdb[options]{db}{filename}#s#%datatoolDB
\DTLmaxforcolumn{db}{key list}{cmd}#
\DTLmaxforkeys[condition][assign list]{db}{key list}{cmd}#
\DTLmeanforcolumn{db}{key list}{cmd}#
\DTLmeanforkeys[condition][assign list]{db}{key list}{cmd}#
\DTLminforcolumn{db}{key list}{cmd}#
\DTLminforkeys{[condition][assign list]{db}{key list}{cmd}#
\DTLnewdbentry{db}{dbkey}{value}#
\DTLnewdb{db}#s#%datatoolDB
\DTLnewrow{db}#
\DTLnewdbonloadfalse#*
\DTLnewdbonloadtrue#*
\DTLnumbernull#*
\DTLrawmap{string}{replacement}#*
\DTLrealtype#*
\DTLremovecurrentrow#
\DTLremoveentryfromrow{dbkey}#
\DTLremoverow{db}{row index}
\DTLreplaceentryforrow{dbkey}{value}
\DTLrowcount{db}#*
\DTLsavedb{db}{filename}
\DTLsavelastrowcount{cmd}#*
\DTLsaverawdb{db}{filename}
\DTLprotectedsaverawdb{db}{filename}
\DTLsavetexdb{db}{filename}
\DTLsdforcolumn{db}{key list}{cmd}#
\DTLsdforkeys[condition][assign list]{db}{key list}{cmd}#
\DTLsetdelimiter{character}#*
\DTLsetheader{db}{dbkey}{header}#
\DTLsetseparator{character}#*
\DTLsettabseparator#*
\DTLsort{sort criteria}{db}
\DTLsort[replacement key list]{sort criteria}{db}
\DTLsort*[replacement key list]{sort criteria}{db}
\DTLstringnull#*
\DTLstringtype#*
\DTLsumcolumn{db}{key list}{cmd}#
\DTLsumforkeys[condition][assign list]{db}{key list}{cmd}#
\DTLswaprows{db}{row1 index}{row2 index}#*
\DTLunsettype#*
\DTLvarianceforcolumn{db}{key list}{cmd}#
\DTLvarianceforkeys{[condition][assign list]{db}{key list}{cmd}#
\datatoolpersoncomma#*
\datatoolplacecomma#*
\datatoolsubjectcomma#*
\datatoolparenstart#*
\dtladdalign{arg1}{arg2}{arg3}{arg4}#S
\dtlaftercols#*
\dtlafterrow#*
\dtlappendentrytocurrentrow{dbkey}{value}#*
\dtlbeforecols#*
\dtlbeforerow#*
\dtlbetweencols#*
\dtlbreak#*
\dtlcolumnindex{db}{dbkey}#*
\dtlcurrencyalign#*
\dtlcurrencyformat{format}#*
\dtldefaultkey#*
\dtldbname#*
\dtldisplayafterhead#*
\dtldisplaycr#*
\dtldisplayendtab#*
\dtldisplaystartrow#*
\dtldisplaystarttab#*
\dtldisplayvalign#*
\dtlexpandnewvalue#*
\dtlforcolumn{cmd}{db}{dbkey}{body}#*
\dtlforcolumnidx{cmd}{db}{col index}{body}#*
\dtlforeachkey(key cs,col cs,type cs,header cs)#*
\in{db}#*
\do{body}#*
\dtlgetentryfromcurrentrow{cmd}{col idx}#*
\dtlgetentryfromrow{arg1}{arg2}{arg3}#S
\dtlgetrowforvalue{db}{col idx}{value}#*
\edtlgetrowforvalue{db}{col idx}{value}#*
\dtlgetrowindex{row cs%cmd}{db}{col idx}{value}#*
\dtlgetrow{db}{row idx}#*
\dtlheaderformat{format}#*
\dtlintalign#*
\dtlintformat{format}#*
\dtllastloadeddb#*
\dtlnoexpandnewvalue#*
\dtlnovalue#*
\dtlrealalign#*
\dtlrealformat{format}#*
\dtlrecombine#*
\dtlrecombineomitcurrent#*
\dtlremoveentryincurrentrow{col idx}#*
\dtlreplaceentryincurrentrow{new value}{col idx}#*
\dtlshowdbkeys{arg1}#S
\dtlshowdb{arg1}#S
\dtlshowtype{arg1}{arg2}#S
\dtlsort[replacement list]{sort criteria}{db}{handler}
\dtlsplitrow{arg1}{arg2}{arg3}{arg4}#S
\dtlstringalign#*
\dtlstringformat{arg1}#S
\dtlswapentriesincurrentrow{col1 idx}{col2 idx}#*
\dtlswaprows{arg1}{arg2}{arg3}#S
\dtlupdateentryincurrentrow{dbkey}{value}#*
\dtlwordindexcompare#*
\end{DTLenvforeach}#
\theDTLrow#*
\theDTLrowi#*
\theDTLrowii#*
\theDTLrowiii#*
\theHDTLrow#*
\theHDTLrowi#*
\theHDTLrowii#*
\theHDTLrowiii#*
\DTLgetvalue#S
\DTLpar#*
\begin{DTLenvforeach}[condition]{db}{assign list}
\begin{DTLenvforeach*}[condition]{db}{assign list}
\dtlshowdb#S
\end{DTLenvforeach*}
\ifdtlnoheader#S
\ifdtlverbose#S
dtlnoheaderfalse#S
dtlnoheadertrue#S
dtlverbosefalse#S
dtlverbosetrue#S
ifDTLnewdbonload#S
